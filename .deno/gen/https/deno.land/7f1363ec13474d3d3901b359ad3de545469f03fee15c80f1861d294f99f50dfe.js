// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/**
 * A module which provides a TypeScript implementation of the Deno CLI's cache
 * directory logic (`DENO_DIR`). This can be used in combination with other
 * modules to provide user loadable APIs that are like the Deno CLI's
 * functionality.
 *
 * This also can provide user read access in Deploy to a Deno CLI's cache when
 * the cache is checked into the repository.
 *
 * ### Example
 *
 * ```ts
 * import { createCache } from "https://deno.land/x/deno_cache/mod.ts";
 * import { createGraph } from "https://deno.land/x/deno_graph/mod.ts";
 *
 * // create a cache where the location will be determined environmentally
 * const cache = createCache();
 * // destructuring the two functions we need to pass to the graph
 * const { cacheInfo, load } = cache;
 * // create a graph that will use the cache above to load and cache dependencies
 * const graph = await createGraph("https://deno.land/x/oak@v9.0.1/mod.ts", {
 *   cacheInfo,
 *   load,
 * });
 *
 * // log out the console a similar output to `deno info` on the command line.
 * console.log(graph.toString());
 * ```
 *
 * @module
 */ import { FetchCacher } from "./cache.ts";
import { DenoDir } from "./deno_dir.ts";
import { FileFetcher } from "./file_fetcher.ts";
export { FetchCacher } from "./cache.ts";
export { DenoDir } from "./deno_dir.ts";
export { FileFetcher } from "./file_fetcher.ts";
/**
 * Creates a cache object that allows access to the internal `DENO_DIR` cache
 * structure for remote dependencies and cached output of emitted modules.
 */ export function createCache({ root , cacheSetting ="use" , allowRemote =true , readOnly  } = {}) {
    const denoDir = new DenoDir(root, readOnly);
    const fileFetcher = new FileFetcher(denoDir.deps, cacheSetting, allowRemote);
    return new FetchCacher(denoDir.gen, denoDir.deps, fileFetcher, readOnly);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZGVub19jYWNoZUAwLjQuMS9tb2QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cblxuLyoqXG4gKiBBIG1vZHVsZSB3aGljaCBwcm92aWRlcyBhIFR5cGVTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIERlbm8gQ0xJJ3MgY2FjaGVcbiAqIGRpcmVjdG9yeSBsb2dpYyAoYERFTk9fRElSYCkuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvdGhlclxuICogbW9kdWxlcyB0byBwcm92aWRlIHVzZXIgbG9hZGFibGUgQVBJcyB0aGF0IGFyZSBsaWtlIHRoZSBEZW5vIENMSSdzXG4gKiBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFRoaXMgYWxzbyBjYW4gcHJvdmlkZSB1c2VyIHJlYWQgYWNjZXNzIGluIERlcGxveSB0byBhIERlbm8gQ0xJJ3MgY2FjaGUgd2hlblxuICogdGhlIGNhY2hlIGlzIGNoZWNrZWQgaW50byB0aGUgcmVwb3NpdG9yeS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVDYWNoZSB9IGZyb20gXCJodHRwczovL2Rlbm8ubGFuZC94L2Rlbm9fY2FjaGUvbW9kLnRzXCI7XG4gKiBpbXBvcnQgeyBjcmVhdGVHcmFwaCB9IGZyb20gXCJodHRwczovL2Rlbm8ubGFuZC94L2Rlbm9fZ3JhcGgvbW9kLnRzXCI7XG4gKlxuICogLy8gY3JlYXRlIGEgY2FjaGUgd2hlcmUgdGhlIGxvY2F0aW9uIHdpbGwgYmUgZGV0ZXJtaW5lZCBlbnZpcm9ubWVudGFsbHlcbiAqIGNvbnN0IGNhY2hlID0gY3JlYXRlQ2FjaGUoKTtcbiAqIC8vIGRlc3RydWN0dXJpbmcgdGhlIHR3byBmdW5jdGlvbnMgd2UgbmVlZCB0byBwYXNzIHRvIHRoZSBncmFwaFxuICogY29uc3QgeyBjYWNoZUluZm8sIGxvYWQgfSA9IGNhY2hlO1xuICogLy8gY3JlYXRlIGEgZ3JhcGggdGhhdCB3aWxsIHVzZSB0aGUgY2FjaGUgYWJvdmUgdG8gbG9hZCBhbmQgY2FjaGUgZGVwZW5kZW5jaWVzXG4gKiBjb25zdCBncmFwaCA9IGF3YWl0IGNyZWF0ZUdyYXBoKFwiaHR0cHM6Ly9kZW5vLmxhbmQveC9vYWtAdjkuMC4xL21vZC50c1wiLCB7XG4gKiAgIGNhY2hlSW5mbyxcbiAqICAgbG9hZCxcbiAqIH0pO1xuICpcbiAqIC8vIGxvZyBvdXQgdGhlIGNvbnNvbGUgYSBzaW1pbGFyIG91dHB1dCB0byBgZGVubyBpbmZvYCBvbiB0aGUgY29tbWFuZCBsaW5lLlxuICogY29uc29sZS5sb2coZ3JhcGgudG9TdHJpbmcoKSk7XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0IHsgdHlwZSBDYWNoZVR5cGUsIEZldGNoQ2FjaGVyIH0gZnJvbSBcIi4vY2FjaGUudHNcIjtcbmltcG9ydCB7IHR5cGUgQ2FjaGVJbmZvLCB0eXBlIExvYWRSZXNwb25zZSB9IGZyb20gXCIuL2RlcHMudHNcIjtcbmltcG9ydCB7IERlbm9EaXIgfSBmcm9tIFwiLi9kZW5vX2Rpci50c1wiO1xuaW1wb3J0IHsgdHlwZSBDYWNoZVNldHRpbmcsIEZpbGVGZXRjaGVyIH0gZnJvbSBcIi4vZmlsZV9mZXRjaGVyLnRzXCI7XG5cbmV4cG9ydCB7IHR5cGUgQ2FjaGVUeXBlLCBGZXRjaENhY2hlciB9IGZyb20gXCIuL2NhY2hlLnRzXCI7XG5leHBvcnQgeyBEZW5vRGlyIH0gZnJvbSBcIi4vZGVub19kaXIudHNcIjtcbmV4cG9ydCB7IHR5cGUgQ2FjaGVTZXR0aW5nLCBGaWxlRmV0Y2hlciB9IGZyb20gXCIuL2ZpbGVfZmV0Y2hlci50c1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlciB7XG4gIC8qKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBhIGBkZW5vX2dyYXBoYCBidWlsZGluZyBmdW5jdGlvbiB0b1xuICAgKiBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWNoZSB0byBwb3B1bGF0ZSB0aGUgb3V0cHV0LlxuICAgKi9cbiAgY2FjaGVJbmZvKHNwZWNpZmllcjogc3RyaW5nKTogQ2FjaGVJbmZvO1xuICAvKiogQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYSBgZGVub19ncmFwaGAgdGhhdCB3aWxsIGxvYWQgYW5kIGNhY2hlXG4gICAqIGRlcGVuZGVuY2llcyBpbiB0aGUgZ3JhcGggaW4gdGhlIGRpc2sgY2FjaGUuXG4gICAqL1xuICBsb2FkKHNwZWNpZmllcjogc3RyaW5nKTogUHJvbWlzZTxMb2FkUmVzcG9uc2UgfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlciB7XG4gIC8qKiBSZXRyaWV2ZSBhIHNwZWNpZmljIHR5cGUgb2YgY2FjaGVkIHJlc291cmNlIGZyb20gdGhlIGRpc2sgY2FjaGUuICovXG4gIGdldCh0eXBlOiBDYWNoZVR5cGUsIHNwZWNpZmllcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuICAvKiogU2V0IGEgc3BlY2lmaWMgdHlwZSBvZiBjYWNoZWQgcmVzb3VyY2UgdG8gdGhlIGRpc2sgY2FjaGUuICovXG4gIHNldCh0eXBlOiBDYWNoZVR5cGUsIHNwZWNpZmllcjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZU9wdGlvbnMge1xuICAvKiogQWxsb3cgcmVtb3RlIFVSTHMgdG8gYmUgZmV0Y2hlZCBpZiBtaXNzaW5nIGZyb20gdGhlIGNhY2hlLiBUaGlzIGRlZmF1bHRzXG4gICAqIHRvIGB0cnVlYC4gU2V0dGluZyBpdCB0byBgZmFsc2VgIGlzIGxpa2UgcGFzc2luZyB0aGUgYC0tbm8tcmVtb3RlYCBpbiB0aGVcbiAgICogRGVubyBDTEksIG1lYW5pbmcgdGhhdCBhbnkgbW9kdWxlcyBub3QgaW4gY2FjaGUgZXJyb3IuICovXG4gIGFsbG93UmVtb3RlPzogYm9vbGVhbjtcbiAgLyoqIERldGVybWluZXMgaG93IHRoZSBjYWNoZSB3aWxsIGJlIHVzZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBcInVzZVwiYFxuICAgKiBtZWFuaW5nIHRoZSBjYWNoZSB3aWxsIGJlIHVzZWQsIGFuZCBhbnkgcmVtb3RlIG1vZHVsZSBjYWNoZSBtaXNzZXMgd2lsbFxuICAgKiBiZSBmZXRjaGVkIGFuZCBzdG9yZWQgaW4gdGhlIGNhY2hlLiAqL1xuICBjYWNoZVNldHRpbmc/OiBDYWNoZVNldHRpbmc7XG4gIC8qKiBUaGlzIGZvcmNlcyB0aGUgY2FjaGUgaW50byBhIGByZWFkT25seWAgbW9kZSwgd2hlcmUgZmV0Y2hlZCByZXNvdXJjZXNcbiAgICogd2lsbCBub3QgYmUgc3RvcmVkIG9uIGRpc2sgaWYgYHRydWVgLiBUaGUgZGVmYXVsdCBpcyBkZXRlY3RlZCBmcm9tIHRoZVxuICAgKiBlbnZpcm9ubWVudCwgY2hlY2tpbmcgdG8gc2VlIGlmIGBEZW5vLndyaXRlRmlsZWAgZXhpc3RzLiAqL1xuICByZWFkT25seT86IGJvb2xlYW47XG4gIC8qKiBTcGVjaWZpZXMgYSBwYXRoIHRvIHRoZSByb290IG9mIHRoZSBjYWNoZS4gU2V0dGluZyB0aGlzIHZhbHVlIG92ZXJyaWRlc1xuICAgKiB0aGUgZGV0ZWN0aW9uIG9mIGxvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50LiAqL1xuICByb290Pzogc3RyaW5nIHwgVVJMO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBpbnRlcm5hbCBgREVOT19ESVJgIGNhY2hlXG4gKiBzdHJ1Y3R1cmUgZm9yIHJlbW90ZSBkZXBlbmRlbmNpZXMgYW5kIGNhY2hlZCBvdXRwdXQgb2YgZW1pdHRlZCBtb2R1bGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoXG4gIHsgcm9vdCwgY2FjaGVTZXR0aW5nID0gXCJ1c2VcIiwgYWxsb3dSZW1vdGUgPSB0cnVlLCByZWFkT25seSB9OiBDYWNoZU9wdGlvbnMgPVxuICAgIHt9LFxuKTogTG9hZGVyICYgQ2FjaGVyIHtcbiAgY29uc3QgZGVub0RpciA9IG5ldyBEZW5vRGlyKHJvb3QsIHJlYWRPbmx5KTtcbiAgY29uc3QgZmlsZUZldGNoZXIgPSBuZXcgRmlsZUZldGNoZXIoZGVub0Rpci5kZXBzLCBjYWNoZVNldHRpbmcsIGFsbG93UmVtb3RlKTtcbiAgcmV0dXJuIG5ldyBGZXRjaENhY2hlcihkZW5vRGlyLmdlbiwgZGVub0Rpci5kZXBzLCBmaWxlRmV0Y2hlciwgcmVhZE9ubHkpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUUxRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBRUQsU0FBeUIsV0FBVyxRQUFRLGFBQWE7QUFFekQsU0FBUyxPQUFPLFFBQVEsZ0JBQWdCO0FBQ3hDLFNBQTRCLFdBQVcsUUFBUSxvQkFBb0I7QUFFbkUsU0FBeUIsV0FBVyxRQUFRLGFBQWE7QUFDekQsU0FBUyxPQUFPLFFBQVEsZ0JBQWdCO0FBQ3hDLFNBQTRCLFdBQVcsUUFBUSxvQkFBb0I7QUFzQ25FOzs7Q0FHQyxHQUNELE9BQU8sU0FBUyxZQUNkLEVBQUUsS0FBSSxFQUFFLGNBQWUsTUFBSyxFQUFFLGFBQWMsSUFBSSxDQUFBLEVBQUUsU0FBUSxFQUFnQixHQUN4RSxDQUFDLENBQUMsRUFDYTtJQUNqQixNQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU07SUFDbEMsTUFBTSxjQUFjLElBQUksWUFBWSxRQUFRLElBQUksRUFBRSxjQUFjO0lBQ2hFLE9BQU8sSUFBSSxZQUFZLFFBQVEsR0FBRyxFQUFFLFFBQVEsSUFBSSxFQUFFLGFBQWE7QUFDakUsQ0FBQyJ9